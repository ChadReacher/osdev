Plans for working on OS:
* Networking:
 - TCP/IP stack:

   - [DONE] Physical layer:		RTL8139 driver
     - [DONE] Introduce macros for registers names and bit names; 
     - [DONE] Test transmitting frames

   - [DONE] Link layer:		Ethernet(DONE), ARP(DONE)
     sudo sh -c 'echo test_ether | xxd -r -p | socat - INTERFACE:tap0'
     - [DONE] Remove malloc() calls, use stack memory;

   - Internet layer:		IPv4, ICMP
     ping -c 1 -s 3100 192.168.0.116
     [DONE] What if the IP address from the other network subnet?
     Add timeout support? (Revise the timer implementation?)

   - Transport layer:		UDP, TCP
     UDP server: nc -l -u 192.168.0.115 -p 2002
     UDP client: echo 'Sky is blue' | nc -u 192.168.0.115 3232

   - Application layer:		DHCP, DNS, HTTP
 - Network sockets (POSIX)
 - Userspace 'ping' utility
 - HTTP server
 - HTTP client

Filesystem:
  * [DONE] Implement pipe as file system
  * [DONE] Implement VFS
    - Research, get more knowledge about working with devices: character- and block-devices
  * [DONE] Support symbolink links in Ext2
  * Implement second file system:
    - Implement MSDOS/FAT32(16)
    - Implement mount() syscall
    - Implement umount() syscall
  * Implement FIFO
  * Implement sockets

Scheduling:
  * [DONE] What about signals? Improve signal management?
  * Make the kernel preemptive?

Memory management:
  * Refactor?
  * Improve?
  * Introduce zones in virtual memory

Core:
  * Introduce multi-user support
  * Introduce password authentication
  * Introduce dynamic libraries
  * Introduce dynamic loader
  * Add bootinfo structure and pass it from bootloader to kernel
  * [DONE] Write code to load kernel which size is bigger than 250 sectors

Devices:
  * Implement several TTYs
  * [DONE] Implement block cache
  * Implement devfs?

Misc:
  * Networking (sockets, after implementing default Unix Domain sockets)
  * Add mkdir -p build directory to Makefile 
  * Add doxygen or another style for comments for functions
  * Add documentation
  * Improve user infrastructure
  * Improve build infrastructure
  * Introduce safe power off
  * Resource scarce OS testing (too many processes, not enough space, etc.)
  * Introduce threads
  * Introduce asynchronous functions
  * Introduce even-driven architecture
  * Introduce kernel stack trace

Plan:
* [DONE] Implement pipe as file system
* [DONE] Support symlinks for ext2
* [DONE] Finish implementing VFS (character and block device operations)
* ...
* [DONE] Improve/revise/simplify/rewrite scheduling algorithm
* [DONE] Improve/revise signals implementation
* ...
* [DONE] Introduce block cache
* [DONE] Implement truncate(2) syscall
* ...
* Introduce memory zones? mmap(2) syscall?
* ...
* Implement Unix domain sockets
* Implement networking sockets
* ...
* Implement MSDOS/FAT32(16) file system
* Implement mount() syscall
* Implement umount() syscall
* ...
* Implement SMP
* Implement threads
* Implement async routines


Open questions/TODOs:
* Where should I perform path resolution? ('./', '../', '././', '/a/..', '/a/b/.././../././', '/hello/', '////hello/////', './///hello/././///..////.//')
* Do we need 'need_resched'. For now, it is used only in 'process_wakeup' routine. It means that we enable the scheduler to work when we we wake up a process.
